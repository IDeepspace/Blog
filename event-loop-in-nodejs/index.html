<!DOCTYPE HTML><html lang="zh-CN"><head><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="keywords" content="Node.JS 中的事件循环机制, Deepspace"><meta name="description" content="一、与浏览器中事件循环机制的差异前面我们对浏览器中的事件循环机制有了一些了解，那 Node 环境下事件循环机制是否也是一致的呢？看段代码：
setTimeout(() =&gt; {
  console.log(&#39;timer1&#39;);

  Pro"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>Node.JS 中的事件循环机制 | Deepspace</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><script src="/libs/jquery/jquery-2.2.0.min.js"></script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="container"><div class="nav-wrapper"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><span></span> <span class="logo-span">Deepspace</span></a></div><a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a><ul class="right"><li class="hide-on-med-and-down"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li><a id="toggleSearch" class="waves-effect waves-light"><i id="searchIcon" class="mdi-action-search"></i></a></li></ul><div class="side-nav" id="mobile-nav"><div class="mobile-head bg-color"><div class="logo-name">Deepspace</div><div class="logo-desc"> 凡事预 ？立 ：废</div></div><ul class="menu-list mobile-menu-list"><li><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li><div class="divider"></div></li><li><a href="https://github.com/IDeepspace" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i> Fork Me</a></li></ul><div class="social-link"><a href="https://github.com/IDeepspace" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a><a href="mailto:cxin1427@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fa fa-envelope-open"></i></a><a href="#!" class="tooltipped" data-tooltip="QQ: 690862036" data-position="top" data-delay="50"><i class="fa fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fa fa-rss"></i></a></div></div></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#202020;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style> <a href="https://github.com/IDeepspace" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewbox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a></nav></header><div class="bg-cover post-cover" style="background-image:url(/medias/featureimages/lighted.jpg)"><div class="container"><div class="row"><div class="col s12 m12 l12"><div class="brand"><div class="description center-align post-detail-title"> Node.JS 中的事件循环机制</div></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1,#articleContent h2,#articleContent h3,#articleContent h4,#articleContent h5,#articleContent h6{padding-top:76px;margin-top:-76px}#articleContent h1{line-height:3.5rem}#articleContent h2{line-height:3.2rem}#articleContent h3{line-height:2.8rem}#articleContent h4{line-height:2.5rem}#articleContent h5{line-height:2.2rem}#articleContent h6{line-height:1.9rem}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px}#toc-content .is-active-link{color:#42b983}#toc-content .is-active-link::before{background-color:#42b983}</style><div class="row"><div class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="article-tag"> <a href="/tags/事件循环/" target="_blank"><span class="chip bg-color">事件循环</span></a></div><div class="post-info"><span class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/NodeJS/" class="post-category" target="_blank">NodeJS</a></span><span class="post-date"><i class="fa fa-clock-o fa-fw"></i> 2019-05-29</span></div></div><hr><div class="card-content article-card-content"><div id="articleContent"><h3 id="一、与浏览器中事件循环机制的差异"><a href="#一、与浏览器中事件循环机制的差异" class="headerlink" title="一、与浏览器中事件循环机制的差异"></a>一、与浏览器中事件循环机制的差异</h3><p>前面我们对浏览器中的事件循环机制有了一些了解，那 <code>Node</code> 环境下事件循环机制是否也是一致的呢？看段代码：</p><pre class="language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><a id="more"></a><p>我们现在浏览器里面运行一下，结果应该和我们预想的一样(如果你已经读过<a href="https://togoblog.cn/event-loop-in-browser/">《浏览器中的事件循环》</a>)：</p><pre class="language-javascript"><code class="language-javascript">timer1
promise1
timer2
promise2
</code></pre><p>再在 <code>Node</code> 环境下运行下，发现运行结果和浏览器中的运行结果并不是一样的：</p><pre class="language-javascript"><code class="language-javascript">timer1
timer2
promise1
promise2
</code></pre><p>所以，浏览器中的事件循环机制和 <code>Node</code> 环境下的时间循环机制是有差异的。之后，我们在谈事件循环机制的时候，就要分不同的场景：浏览器环境和 <code>Node</code> 环境，不能混为一谈。</p><p>简单的讲：</p><ul><li><code>Node.js</code> 的 <code>event loop</code> 是基于 <code>libuv</code> 实现，而浏览器的 <code>event loop</code> 则在 <code>HTML5</code> 的规范中定义。</li><li><code>libuv</code> 已经对 <code>event loop</code> 作出了实现，而 <code>HTML5</code> 规范中只是定义了浏览器中 <code>event loop</code> 的模型，具体实现留给了浏览器厂商。</li></ul><blockquote><p>对于上面的代码在 <code>Node</code> 环境中执行结果的原因，我会在下文解释。</p></blockquote><h3 id="二、Node-js-的架构"><a href="#二、Node-js-的架构" class="headerlink" title="二、Node.js 的架构"></a>二、Node.js 的架构</h3><p>把 <code>Node.js</code> 拆分到组件，看看它们的关键作用是什么、如何交互协作。 <code>Node.js</code> 运行时环境图示：</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/nodejs-architecture.png" alt="node.js 架构图" style="zoom:67%"></p><p align="center">(图片来自网络)</p><p><strong>1、Application/Modules（JS）</strong>：这部分就是所有的 <code>JavaScript</code> 代码：我们的应用程序、<code>Node.js</code> 核心模块、任何 <code>npm install</code> 的模块，以及你写的所有模块代码等等，我们花费的主要精力都在这部分。</p><p><strong>2、C/C++ Bindings</strong>：<code>Node.js</code> 中用了很多 <code>C/C++</code> 的代码和库，它们的性能很好。但是这三种不同的语言是怎么相互调用的呢？<code>Bindings</code> 就在这里发挥了作用。<code>Bindings</code> 是一些胶水代码，能够把不同语言绑定在一起，使其能够互相沟通调用。</p><p><strong>3、Addons</strong>：<code>Binding</code> 仅桥接 <code>Node.js</code> 核心库的一些依赖，<code>zlib</code>、<code>OpenSSL</code>、<code>c-ares</code>、<code>http-parser</code> 等。如果你想在应用程序中包含其他第三方或者自己的 <code>C/C++</code> 库的话，需要自己完成这部分胶水代码。那我们自己写的这部分胶水代码就称为 <code>Addon</code>。可以把 <code>Binding</code> 和 <code>Addons</code> 视为连接 <code>JavaScript</code> 代码和 <code>C/C++</code> 代码的桥梁。</p><p><a href="https://developers.google.com/v8/" target="_blank" rel="noopener"><strong>4、V8</strong></a>：<code>Google</code> 开源的高性能 <code>JavaScript</code> 引擎，以 <code>C++</code> 实现。这也是集成在 <code>Chrome</code> 中的 <code>JS</code> 引擎。<code>V8</code> 将你写的 <code>JavaScript</code> 代码编译为机器码（所以它超级快）然后执行。</p><p><a href="https://github.com/libuv/libuv" target="_blank" rel="noopener"><strong>5、libuv</strong></a>：提供异步功能的 <code>C</code> 库。它在运行时负责一个事件循环（<code>Event Loop</code>）、一个线程池、文件系统 <code>I/O</code>、<code>DNS</code> 相关和网络 <code>I/O</code>，以及一些其他重要功能。</p><p><a href="https://nodejs.org/en/docs/meta/topics/dependencies/" target="_blank" rel="noopener"><strong>6、其他 C/C++ 组件和库</strong></a>：如 <a href="http://c-ares.haxx.se/" target="_blank" rel="noopener">c-ares</a>、<a href="https://www.openssl.org/" target="_blank" rel="noopener">crypto (OpenSSL)</a>、<a href="https://github.com/nodejs/http-parser" target="_blank" rel="noopener">http-parser</a> 以及 <a href="http://zlib.net/" target="_blank" rel="noopener">zlib</a>。这些依赖提供了对系统底层功能的访问，包括网络、压缩、加密等。</p><p>下面我们看看 <code>Node.js</code> 中的事件循环。</p><h3 id="三、事件循环"><a href="#三、事件循环" class="headerlink" title="三、事件循环"></a>三、事件循环</h3><p>上面我们对 <code>Node.js</code> 架构中的顶层组件有了一个简单的了解。</p><p>在 <code>Node.js</code> 中，也是单线程的事件循环。<code>Nodejs</code> 的事件循环会分为6个阶段，它们会按照顺序反复运行。</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/nodejs-eventloop-structure.jpg" alt="NodeJS事件循环" style="zoom:50%"></p><p>每个阶段的作用如下:</p><ol><li><p><code>timers</code> 阶段：这个阶段执行 <code>timer</code> (包括 <code>setTimeout</code>、<code>setInterval</code>) 的回调；</p></li><li><p><code>I/O callbacks</code> 阶段：执行 <code>I/O</code>（例如文件、网络）的回调；</p></li><li><p><code>idle, prepare</code> 阶段：队列的移动，仅 <code>node</code> 内部使用；</p></li><li><p><code>poll</code> 阶段：最重要的阶段，获取新的 <code>I/O</code> 事件, 适当的条件下 <code>node</code> 将阻塞在这里；</p></li><li><p><code>check</code> 阶段：执行 <code>setImmediate()</code> 的 <code>callback</code>；</p></li><li><p><code>close callbacks</code> 阶段：执行 <code>close</code> 事件的 <code>callback</code>，例如 <code>socket.on(&quot;close&quot;,func)</code></p></li></ol><p>我们重点看 <code>timers</code>、<code>poll</code>、<code>check</code> 这3个阶段就好，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p><h4 id="1、timers-阶段"><a href="#1、timers-阶段" class="headerlink" title="1、timers 阶段"></a>1、timers 阶段</h4><p><code>timers</code> 是事件循环的第一个阶段，<code>Node</code> 会去检查有无已过期的 <code>timer</code>，如果有则把它的回调压入 <code>timer</code> 的任务队列中等待执行。</p><p>事实上，<code>Node</code> 并不能保证 <code>timer</code> 在预设时间到了就会立即执行，因为 <code>Node</code> 对 <code>timer</code> 的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，<code>setTimeout()</code> 和 <code>setImmediate()</code> 的执行顺序是不确定的。</p><pre class="language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>但是把它们放到一个 <code>I/O</code> 回调里面，就一定是 <code>setImmediate()</code> 先执行，因为 <code>poll</code> 阶段后面就是 <code>check</code> 阶段。</p><h4 id="2、poll-阶段"><a href="#2、poll-阶段" class="headerlink" title="2、poll 阶段"></a>2、poll 阶段</h4><p><code>poll</code> 阶段主要有2个功能：</p><ul><li>处理 <code>poll</code> 队列的事件</li><li>当有已超时的 <code>timer</code>，执行它的回调函数</li></ul><p><code>even loop</code> 将同步执行 <code>poll</code> 队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来 <code>even loop</code> 会去检查有无预设的 <code>setImmediate()</code>，分两种情况：</p><ol><li>若有预设的 <code>setImmediate()</code>，<code>event loop</code> 将结束 <code>poll</code> 阶段进入 <code>check</code> 阶段，并执行 <code>check</code> 阶段的任务队列；</li><li>若没有预设的 <code>setImmediate()</code>，<code>event loop</code> 将阻塞在该阶段等待。</li></ol><p>注意一个细节，没有 <code>setImmediate()</code> 会导致 <code>event loop</code> 阻塞在 <code>poll</code> 阶段，这样之前设置的 <code>timer</code> 岂不是执行不了了？所以呢，在 <code>poll</code> 阶段 <code>event loop</code> 会有一个检查机制，检查 <code>timer</code> 队列是否为空，如果 <code>timer</code> 队列非空，<code>event loop</code> 就开始下一轮事件循环，即重新进入到 <code>timer</code> 阶段。</p><h4 id="3、check-阶段"><a href="#3、check-阶段" class="headerlink" title="3、check 阶段"></a>3、check 阶段</h4><p><code>setImmediate()</code> 的回调会被加入 <code>check</code> 队列中， 从 <code>event loop</code> 的阶段图可以知道，<code>check</code> 阶段的执行顺序在 <code>poll</code> 阶段之后。</p><p><strong>小结一下：</strong></p><ul><li><code>event loop</code> 的每个阶段都有一个任务队列；</li><li>当 <code>event loop</code> 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段；</li><li>当所有阶段被顺序执行一次后，称 <code>event loop</code> 完成了一个 <code>tick</code>。</li></ul><p>看个 <code>demo</code> :</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'readFile'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>结果：</p><pre><code>readFile
immediate
timeout
</code></pre><h3 id="四、Node-js-与浏览器的-Event-Loop-差异"><a href="#四、Node-js-与浏览器的-Event-Loop-差异" class="headerlink" title="四、Node.js 与浏览器的 Event Loop 差异"></a>四、Node.js 与浏览器的 Event Loop 差异</h3><p>现在我们回到文章开头提到的问题，为什么 <code>Node.js</code> 与浏览器的 <code>Event Loop</code> 差异在什么地方呢？</p><p><strong>回顾一下：</strong></p><p>浏览器环境下，<code>microtask</code> 的任务队列是每个 <code>macrotask</code> 执行完之后执行。</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/eventLoop-browser-2.png" alt="事件循环" style="zoom:87%"></p><p align="center">(图片来自网络)</p><p>而在 <code>Node.js</code> 中，<strong><code>microtask</code> 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 <code>microtask</code> 队列的任务。</strong></p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/nodejs-eventloop-structure.jpg" alt="NodeJS事件循环" style="zoom:50%"></p><p>文章最开始的 <code>demo</code>，在 <code>Node.js</code> 环境中，全局脚本 <code>main()</code> 执行，将 2 个 <code>timer</code> 依次放入 <code>timer</code> 队列，<code>main()</code> 执行完毕，执行栈空闲，任务队列开始执行：</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/node-excute-animate.gif" alt="NodeJS事件循环"></p><p align="center">(图片来自网络)</p><ul><li><p>首先进入 <code>timers</code> 阶段，执行 <code>timer1</code> 的回调函数，打印 <code>timer1</code>，并将 <code>promise1.then</code> 回调放入 <code>microtask</code> 队列，同样的步骤执行 <code>timer2</code> ，打印 <code>timer2</code>；</p></li><li><p>至此，<code>timer</code> 阶段执行结束，<code>event loop</code> 进入下一个阶段之前，执行 <code>microtask</code> 队列的所有任务，依次打印 <code>promise1</code>、<code>promise2</code>。</p></li></ul><p><strong>对比浏览器端的处理过程：</strong></p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/browser-event-loop-excute-animate.gif" alt="事件循环"></p><p align="center">(图片来自网络)</p><h3 id="五、process-nextTick-和-setImmediate"><a href="#五、process-nextTick-和-setImmediate" class="headerlink" title="五、process.nextTick 和 setImmediate"></a>五、process.nextTick 和 setImmediate</h3><p>除了 <code>setTimeout</code> 和 <code>setInterval</code> 这两个方法，<code>Node.js</code> 还提供了另外两个与 <strong>任务队列</strong> 有关的方法：<a href="http://nodejs.org/docs/latest/api/process.html#process_process_nexttick_callback" target="_blank" rel="noopener">process.nextTick</a> 和 <a href="http://nodejs.org/docs/latest/api/timers.html#timers_setimmediate_callback_arg" target="_blank" rel="noopener">setImmediate</a>。它们可以帮助我们加深对 <strong>任务队列</strong> 的理解。</p><p><code>process.nextTick()</code> 会在各个事件阶段之间执行，一旦执行，要直到 <code>nextTick</code> 队列被清空，才会进入到下一个事件阶段，所以如果递归调用 <code>process.nextTick()</code>，会导致出现 <code>I/O starving</code> （饥饿）的问题。</p><p>比如下面例子的 <code>readFile</code> 已经完成，但它的回调一直无法执行：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> starttime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> endtime<span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'text.txt'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
  endtime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'finish reading time: '</span><span class="token punctuation">,</span> endtime <span class="token operator">-</span> starttime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">>=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`nextTick </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// console.log(`setImmediate ${index}`)</span>
  <span class="token comment" spellcheck="true">// setImmediate(handler)</span>
<span class="token punctuation">}</span>

<span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p><code>process.nextTick()</code> 的运行结果：</p><pre class="language-shell"><code class="language-shell">nextTick 1
nextTick 2
......
nextTick 999
nextTick 1000
finish reading time: 170
</code></pre><p>替换成 <code>setImmediate()</code>，运行结果：</p><pre class="language-shell"><code class="language-shell">setImmediate 1
setImmediate 2
finish reading time: 80
......
setImmediate 999
setImmediate 1000
</code></pre><p>这是因为嵌套调用的 <code>setImmediate()</code> 回调，被排到了下一次 <code>event loop</code> 才执行，所以不会出现阻塞。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ol><li><p><code>Node.js</code> 的事件循环分为6个阶段；</p></li><li><p>浏览器和 <code>Node</code> 环境下，<code>microtask</code> 任务队列的执行时机不同</p><ul><li><p><code>Node.js</code> 中，<code>microtask</code> 在事件循环的各个阶段之间执行</p></li><li><p>浏览器端，<code>microtask</code> 在事件循环的 <code>macrotask</code> 执行完之后执行</p></li></ul></li><li><p>递归的调用 <code>process.nextTick()</code> 会导致 <code>I/O starving</code> ，官方推荐使用 <code>setImmediate()</code></p></li></ol></div><hr><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.88rem}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{color:#fff}.reward-tabs .wechat-tab .active{color:#fff;background-color:#22ab38}.reward-tabs .alipay-tab .active{color:#fff;background-color:#019fe8}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"> <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close"><i class="fa fa-close"></i></a><h4 class="reward-title">请我喝杯咖啡?</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs"><li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li><li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li></ul><div id="wechat"> <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div><div id="alipay"> <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码"></div></div></div></div></div></div><script>$(function(){$("#reward .reward-link").on("click",function(){$("#rewardModal").openModal()}),$("#rewardModal .close").on("click",function(){$("#rewardModal").closeModal()})})</script><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div></div><script src="/libs/share/js/social-share.min.js"></script><div class="reprint"><p> <span class="reprint-tip">转载请注明:</span> <a href="https://togoblog.cn" class="b-link-green">Deepspace</a><i class="fa fa-angle-right fa-lg fa-fw text-color"></i> <a href="/event-loop-in-nodejs/" class="b-link-green">Node.JS 中的事件循环机制</a></p></div></div></div><div class="article" data-aos="fade-up"><div class="card relate-article-wrapper"><header class="relate-article-header">相关文章&nbsp;<i class="fa fa-arrow-right"></i></header><div class="relate-post-box"><div class="relate-post"> <span>1、</span><a id="relate-post-link" href="/eventemitter/">EventEmitter</a></div><div class="relate-post"> <span>2、</span><a id="relate-post-link" href="/express-mongoose/">Express + Mongoose 实现增删改查</a></div><div class="relate-post"> <span>3、</span><a id="relate-post-link" href="/event-loop-in-browser/">浏览器中的事件循环机制</a></div></div></div></div><div class="disqus-card card" data-aos="fade-up"><div id="disqus_thread" class="card-content"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><script type="text/javascript">
    disqus_config = function () {
        this.page.url = 'https://togoblog.cn/event-loop-in-nodejs/';
        this.page.identifier = '/event-loop-in-nodejs/';
        this.page.title = 'Node.JS 中的事件循环机制';
    };
    let disqus_shortname = 'https-togoblog-cn';

    (function () { // DON'T EDIT BELOW THIS LINE
        let d = document, s = d.createElement('script');
        // 如：s.src = 'https://Deepspace.disqus.com/embed.js';
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script></div></div><div class="col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title">目录</div><div id="toc-content"></div></div></div></div><script src="/libs/tocbot/tocbot.min.js"></script><script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingSelector: 'h2, h3, h4, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right"> <span>COPYRIGHT 2020 DEEPSPACE. ALL RIGHTS RESERVED.</span></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/IDeepspace" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a><a href="mailto:cxin1427@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fa fa-envelope-open"></i></a><a href="#!" class="tooltipped" data-tooltip="QQ: 690862036" data-position="top" data-delay="50"><i class="fa fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fa fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"> <span class="title">搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input" autofocus></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">searchFunc("/search.xml","searchInput","searchResult")</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/js/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script></body></html>