<!DOCTYPE HTML><html lang="zh-CN"><head><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="keywords" content="浏览器中的事件循环机制, Deepspace"><meta name="description" content="
在看 Event loop 的时候，我发现相关的文章有很多，但是有的文章写得零碎，有的文章只讲解了浏览器或者 Node 环境之一的事件循环，这两者如果没有对比起来理解的话，总是觉得比较模糊。所以在读了很多文章之后，整理出来本文，本篇文章为"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>浏览器中的事件循环机制 | Deepspace</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><script src="/libs/jquery/jquery-2.2.0.min.js"></script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="container"><div class="nav-wrapper"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><span></span> <span class="logo-span">Deepspace</span></a></div><a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a><ul class="right"><li class="hide-on-med-and-down"><a href="/" class="waves-effect waves-light"><i class="fa fa-home"></i> <span>首页</span></a></li><li class="hide-on-med-and-down"><a href="/tags" class="waves-effect waves-light"><i class="fa fa-tags"></i> <span>标签</span></a></li><li class="hide-on-med-and-down"><a href="/categories" class="waves-effect waves-light"><i class="fa fa-bookmark"></i> <span>分类</span></a></li><li class="hide-on-med-and-down"><a href="/archives" class="waves-effect waves-light"><i class="fa fa-archive"></i> <span>归档</span></a></li><li class="hide-on-med-and-down"><a href="/about" class="waves-effect waves-light"><i class="fa fa-user-circle-o"></i> <span>关于</span></a></li><li><a id="toggleSearch" class="waves-effect waves-light"><i id="searchIcon" class="mdi-action-search"></i></a></li></ul><div class="side-nav" id="mobile-nav"><div class="mobile-head bg-color"><div class="logo-name">Deepspace</div><div class="logo-desc"> 凡事预 ？立 ：废</div></div><ul class="menu-list mobile-menu-list"><li><a href="/" class="waves-effect waves-light"><i class="fa fa-fw fa-home"></i> 首页</a></li><li><a href="/tags" class="waves-effect waves-light"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li><a href="/categories" class="waves-effect waves-light"><i class="fa fa-fw fa-bookmark"></i> 分类</a></li><li><a href="/archives" class="waves-effect waves-light"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li><a href="/about" class="waves-effect waves-light"><i class="fa fa-fw fa-user-circle-o"></i> 关于</a></li><li><div class="divider"></div></li><li><a href="https://github.com/IDeepspace" class="waves-effect waves-light" target="_blank"><i class="fa fa-github-square fa-fw"></i> Fork Me</a></li></ul><div class="social-link"><a href="https://github.com/IDeepspace" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a><a href="mailto:cxin1427@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fa fa-envelope-open"></i></a><a href="#!" class="tooltipped" data-tooltip="QQ: 690862036" data-position="top" data-delay="50"><i class="fa fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fa fa-rss"></i></a></div></div></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#202020;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style> <a href="https://github.com/IDeepspace" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewbox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a></nav></header><div class="bg-cover post-cover" style="background-image:url(/medias/featureimages/lighted.jpg)"><div class="container"><div class="row"><div class="col s12 m12 l12"><div class="brand"><div class="description center-align post-detail-title"> 浏览器中的事件循环机制</div></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1,#articleContent h2,#articleContent h3,#articleContent h4,#articleContent h5,#articleContent h6{padding-top:76px;margin-top:-76px}#articleContent h1{line-height:3.5rem}#articleContent h2{line-height:3.2rem}#articleContent h3{line-height:2.8rem}#articleContent h4{line-height:2.5rem}#articleContent h5{line-height:2.2rem}#articleContent h6{line-height:1.9rem}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px}#toc-content .is-active-link{color:#42b983}#toc-content .is-active-link::before{background-color:#42b983}</style><div class="row"><div class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="article-tag"> <a href="/tags/事件循环/" target="_blank"><span class="chip bg-color">事件循环</span></a></div><div class="post-info"><span class="post-cate"><i class="fa fa-bookmark fa-fw icon-category"></i> <a href="/categories/NodeJS/" class="post-category" target="_blank">NodeJS</a></span><span class="post-date"><i class="fa fa-clock-o fa-fw"></i> 2019-05-28</span></div></div><hr><div class="card-content article-card-content"><div id="articleContent"><blockquote><p>在看 Event loop 的时候，我发现相关的文章有很多，但是有的文章写得零碎，有的文章只讲解了浏览器或者 Node 环境之一的事件循环，这两者如果没有对比起来理解的话，总是觉得比较模糊。所以在读了很多文章之后，整理出来本文，本篇文章为《浏览器中的事件循环》，下一篇为《<a href="https://togoblog.cn/event-loop-in-nodejs/">Node.JS中的事件循环</a>》，二者对比起来理解会更好。</p></blockquote><h3 id="一、单线程和异步"><a href="#一、单线程和异步" class="headerlink" title="一、单线程和异步"></a>一、单线程和异步</h3><p>提到 <code>JavaScript</code> ，就会想到它的 <strong>单线程</strong> 和 <strong>异步</strong> 两大特性。那么在 <code>JavaScript</code> 中单线程是如何做到异步的呢？我们先了解一下单线程和异步之间的关系。</p><p><code>JavaScript</code> 中的任务分为 <strong>同步</strong> 和 <strong>异步</strong> 两种，它们的处理方式存在很大的不同。</p><h4 id="1、异步"><a href="#1、异步" class="headerlink" title="1、异步"></a>1、异步</h4><p><strong>同步任务</strong> 是直接在 <strong>主线程</strong> 上排队执行。在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。所有同步任务都在主线程上执行，形成一个 <strong>执行栈</strong>（<code>execution context stack</code>）。</p><p><strong>异步任务</strong> 则是被放在 <strong>任务队列</strong> (<code>task queue</code>) 中，不进入主线程，只有 <strong>任务队列</strong> 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。任务队列类似一个缓冲区，任务下一步会被移到 <strong>执行栈</strong>，然后主线程执行 <strong>执行栈</strong> 的任务。如果有多个异步任务，那这些异步任务就要在任务队列中排队等候。</p><a id="more"></a><p>主线程和任务队列的示意图：</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/main-thread-and-task-queue.jpg" alt="主线程和任务队列" style="zoom:77%"></p><p align="center">(图片来自网络)</p><h4 id="2、单线程"><a href="#2、单线程" class="headerlink" title="2、单线程"></a>2、单线程</h4><p><code>JavaScript</code> 中其实是没有线程概念的，所谓的单线程也只是相对于多线程而言。<strong>线程</strong> 本来就不属于 <code>JavaScript</code> 语言的范畴，只是为了和其它语言做对比而已，为了让那些用过多线程语言的人理解 <code>JavaScript</code> 的特点。</p><p>单线程是指 <code>JavaScript</code> 引擎中负责解析执行 <code>JavaScript</code> 代码的线程只有一个（<strong>主线程</strong>），即每次只能做一件事。</p><blockquote><p>注意：所谓的 <code>JavaScript</code> 是单线程的，是指 <code>JavaScript</code> 运行在浏览器中是单线程的，叫做 <code>JavaScript</code> 引擎线程。但是浏览器不是单线程的。</p></blockquote><p>浏览器是<strong>事件驱动（<code>Event driven</code>）</strong>的。浏览器中很多异步行为都是由浏览器新开一个线程去完成的，它会创建事件并放入执行队列中。<code>JavaScript</code> 引擎是单线程处理任务队列，它只是浏览器多个线程中的一个。所以当多个事件触发时，会依次放入队列，然后一个一个响应。</p><p>浏览器还包括很多其他线程，如界面渲染线程，浏览器事件触发线程，<code>Http</code> 请求线程等。</p><p>怎么证明 <code>JavaScript</code> 是单线程的呢？ 看段代码：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'second'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>上面的代码中，<code>JavaScript</code> 引擎 <code>5ms</code> 后会把打印 <code>second</code> 的任务加入队列，而当前有任务，所以只能等 <code>1000000</code> 个 <code>first</code> 打印完后才会打印 <code>second</code> 。所以执行结果会首先全部打印 <code>first</code> ，然后再全部打印 <code>second</code> ，即使中间的执行时间超过 <code>5ms</code> 。</p><p>由此可见，<code>JavaScript</code> 是单线程的。</p><h4 id="3、ajax-请求"><a href="#3、ajax-请求" class="headerlink" title="3、ajax 请求"></a>3、ajax 请求</h4><p>我们知道一个当发出 <code>ajax</code> 请求的时候，主线程在等待它响应的同时是会去做其它事情的。浏览器先在事件表中注册 <code>ajax</code> 的回调函数，响应回来后回调函数被添加到任务队列中等待执行，不会造成线程阻塞，所以说 <code>JavaScript</code> 处理 <code>ajax</code> 请求的方式是异步的。</p><h3 id="二、事件循环"><a href="#二、事件循环" class="headerlink" title="二、事件循环"></a>二、事件循环</h3><p>根据上面的描述，<code>JavaScript</code> 检查执行栈是否为空，以及确定把哪个 <code>task</code> 加入执行栈的这个过程就是 <strong>事件循环</strong>，<code>JavaScript</code> 实现异步的核心就是事件循环。</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/eventLoop-browser.png" alt="事件循环" style="zoom:77%"></p><p align="center">(图片来自网络)</p><p>主线程运行的时候，产生堆（<code>heap</code>）和栈（<code>stack</code>），栈中的代码调用各种外部 <code>API</code>，它们在 <strong>任务队列</strong> 中加入各种事件（<code>click</code>，<code>load</code>，<code>done</code> 等）。只要执行栈中的代码执行完毕，主线程就会去读取 <strong>任务队列</strong> ，依次执行那些事件所对应的回调函数。</p><blockquote><p><strong>注意：执行栈中的代码（同步任务），总是在读取 “任务队列”（异步任务）之前执行。</strong></p></blockquote><h3 id="三、在浏览器中的实现"><a href="#三、在浏览器中的实现" class="headerlink" title="三、在浏览器中的实现"></a>三、在浏览器中的实现</h3><p>浏览器中，一个事件循环里有很多个来自不同任务源的任务队列（<code>task queues</code>），每一个任务队列里的任务是严格按照<strong>先进先出</strong>的顺序执行的。但是，因为<strong>浏览器自己调度</strong>的关系，<strong>不同任务队列的任务的执行顺序是不确定</strong>的。举个例子：</p><pre><code>浏览器有一个处理鼠标和键盘事件的任务队列。浏览器可以给这个队列比其他队列多3/4的执行时间，以确保交互的响应而不让其他任务队列饿死（starving），并且不会乱序处理任何一个任务队列的事件。
</code></pre><p>任务被分为 <code>Task</code>（又称为 <code>MacroTask</code>，宏任务）和 <code>MicroTask</code>（微任务）两种。那哪些行为属于 <code>MacroTask</code>，哪些又属于 <code>MicroTask</code> 呢？</p><ul><li><strong>MacroTask</strong>：<code>script</code>（整体代码）， <code>setTimeout</code>， <code>setInterval</code>， <code>setImmediate</code>（<code>node</code>独有）， <code>I/O</code>， <code>UI rendering</code> ;</li><li><strong>MicroTask</strong>：<code>process.nextTick</code>（<code>node</code>独有）， <code>Promises</code>，<code>Object.observe</code>（废弃）， <code>MutationObserver</code> 。</li></ul><p>关于 <code>macrotask</code> 和 <code>microtask</code> 的理解，光这样描述会有些晦涩难懂，结合事件循坏的机制理解会清晰很多，下面这张图可以说是介绍得非常清楚了：</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/eventLoop-browser-1.jpg" alt="事件循环" style="zoom:87%"></p><p align="center">(图片来自网络)</p><p>总结一下上图，<strong>事件循环的进程模型</strong>：</p><ul><li>浏览器会不断从 <code>macrotask</code> 队列中按顺序取 <code>macrotask</code> 执行</li><li>每执行完一个 <code>macrotask</code> 都会检查 <code>microtask</code> 队列是否为空（执行完一个 <code>macrotask</code> 的具体标志是函数执行栈为空）</li><li>如果 <code>microtask</code> 队列不为空，则会<strong>一次性执行完</strong>所有 <code>microtask</code>，直到 <code>microtasks</code> 队列全部清空。</li><li>更新界面渲染</li><li>返回第一步，再进入下一个循环去 <code>macrotask</code> 队列中取下一个 <code>macrotask</code> 执行</li></ul><p><code>macrotask</code> 和 <code>microtask</code> 的执行顺序：</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/eventLoop-browser-2.png" alt="事件循环" style="zoom:77%"></p><p align="center">(图片来自网络)</p><p><strong>这里需要 <code>highlight</code> 的是：<code>microtask queue</code> 中的 <code>task</code> 会在事件循环的当前回合中执行，因此 <code>macrotask queue</code> 中的 <code>task</code> 就只能等到事件循环的下一个回合中执行了。</strong></p><blockquote><p>注意：图中橙色的 MacroTask 任务队列也应该是在不断被切换着的。</p></blockquote><p>我们看段代码：</p><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><blockquote><p>代码来自 <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a> .</p></blockquote><p>在这里，<code>setTimeout</code> 的延时为 0，而 <code>Promise.resolve()</code> 也是返回一个被 <code>resolve</code> 了 <code>promise</code> 对象，即这里的 <code>then</code> 方法中的函数也是相当于异步的立即执行任务，那么他们到底是谁在前谁在后？</p><p>正确的打印顺序是：</p><pre><code>start
end
promise1
promise2
setTimeout
</code></pre><p><strong>这里的运行结果是 <code>Promise</code> 的立即返回的异步任务会优先于 <code>setTimeout</code> 延时为 0 的任务执行。</strong></p><p>看看执行过程：</p><p><img src="https://raw.githubusercontent.com/IDeepspace/ImageHosting/master/NodeJS/browser-event-loop-excute-animate.gif" alt="事件循环"></p><p align="center">(图片来自网络)</p><ul><li><p>一开始 <code>task</code> 队列中只有 <code>script</code>，则 <code>script</code> 中所有函数放入函数执行栈执行，代码按顺序执行。</p></li><li><p>接着遇到了 <code>setTimeout</code><strong>，它的作用是 <code>0ms</code> 后将回调函数放入 <code>task</code> 队列中</strong>，<strong>也就是说这个函数将在下一个事件循环中执行。</strong></p></li><li><p>接着遇到了 <code>Promise</code>，按照前面所述 <code>Promise</code> 属于 <code>microtask</code> ，所以第一个 <code>.then()</code> 会放入 <code>microtask</code> 队列。</p></li><li><p>当所有 <code>script</code> 代码执行完毕后，<strong>此时函数执行栈为空</strong>。 <strong><code>microtask queue</code> 中的 <code>task</code> 会在事件循环的当前回合中执行。</strong>所以，开始检查 <code>microtask</code> 队列，此时 <code>microtask</code> 队列不为空，执行 <code>.then()</code> 的回调函数输出 <code>&#39;promise1&#39;</code>，由于 <code>.then()</code> 返回的依然是 <code>promise</code> ，所以第二个 <code>.then()</code> 会放入 <code>microtask</code> 队列继续执行，输出 <code>&#39;promise2&#39;</code> 。也就是说如果我的某个 <code>microtask</code> 任务又推入了一个任务进入 <code>microtasks</code> 队列，那么在主线程完成该任务之后，仍然会继续运行 <code>microtasks</code> 任务，直到任务队列耗尽。</p></li><li><p>此时 <code>microtask</code> 队列为空了，进入下一个事件循环，检查 <code>task</code> 队列发现了 <code>setTimeout</code> 的回调函数，立即执行回调函数输出 <code>&#39;setTimeout&#39;</code>，代码执行完毕。</p></li><li>这个过程会不断重复，也就是所谓的<strong>事件循环</strong>。</li></ul><h4 id="1、Promise-和-async-中的立即执行"><a href="#1、Promise-和-async-中的立即执行" class="headerlink" title="1、Promise 和 async 中的立即执行"></a>1、Promise 和 async 中的立即执行</h4><p>下面再看个例子：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/*
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/</span>
</code></pre><p><strong>解析：</strong></p><p>我们知道 <code>Promise</code> 中的异步体现在 <code>then</code> 和 <code>catch</code> 中，所以写在 <code>Promise</code> 中的代码是被当做同步任务立即执行的。而在 <code>async/await</code> 中，在出现 <code>await</code> 出现之前，其中的代码也是立即执行的。</p><p>因为 <code>async await</code> 本身就是 <code>promise+generator</code> 的语法糖。所以 <code>await</code> 后面的代码是 <code>microtask</code>。所以，例子中的：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>等价于：</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p><code>async</code> 函数中在 <code>await</code> 之前的代码是立即执行的，所以会立即输出 <code>async1 start</code>。</p><p>遇到了 <code>await</code> 时，会将 <code>await</code> 后面的表达式执行一遍，所以就紧接着输出 <code>async2</code>，然后将 <code>await</code> 后面的代码也就是 <code>console.log(&#39;async1 end&#39;)</code> 加入到 <code>microtask</code> 中的 <code>Promise</code> 队列中，接着跳出 <code>async1</code> 函数来执行后面的代码。</p><p><code>script</code> 任务继续往下执行，遇到 <code>Promise</code> 实例（注意是实例）。由于 <code>Promise</code> 中的函数是立即执行的，而后续的 <code>.then</code> 则会被分发到 <code>microtask</code> 的 <code>Promise</code> 队列中去。所以会先输出 <code>promise1</code>，然后执行 <code>resolve</code>，将 <code>promise2</code> 分配到对应队列。</p><p><code>script</code> 任务继续往下执行，最后只有一句输出了 <code>script end</code>，至此，全局任务就执行完毕了。</p><p>根据上述，每次执行完一个宏任务之后，会去检查是否存在 <code>Microtasks</code>；如果有，则执行 <code>Microtasks</code> 直至清空 <code>Microtask Queue</code>。</p><p>因而在 <code>script</code> 任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， <code>Promise</code> 队列有的两个任务 <code>async1 end</code> 和 <code>promise2</code>，因此按先后顺序输出 <code>async1 end，promise2</code>。当所有的 <code>Microtasks</code> 执行完毕之后，表示第一轮的循环就结束了。</p><p>第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 <code>setTimeout</code>，取出直接输出即可，至此整个流程结束。</p><h4 id="2、变式"><a href="#2、变式" class="headerlink" title="2、变式"></a>2、变式</h4><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//async2做出如下更改：</span>
    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/*
script start
async1 start
promise1
promise3
script end
promise2
async1 end
promise4
setTimeout
*/</span>
</code></pre><p>在第一次 <code>macrotask</code> 执行完之后，也就是输出 <code>script end</code> 之后，会去清理所有 <code>microtask</code>。所以会相继输出 <code>promise2</code>，<code>async1 end</code> ，<code>promise4</code>。</p><h3 id="四、定时器"><a href="#四、定时器" class="headerlink" title="四、定时器"></a>四、定时器</h3><p>除了放置异步任务的事件，<strong>任务队列</strong> 中还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫作 <strong>定时器（<code>timer</code>）</strong>功能，也就是定时执行的代码。</p><p>定时器功能主要由 <code>setTimeout()</code> 和 <code>setInterval()</code> 这两个函数来完成，它们两个的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。下面看段代码：</p><pre class="language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>输出结果为：</p><pre class="language-javascript"><code class="language-javascript"><span class="token number">1</span>
<span class="token number">3</span>
<span class="token number">2</span>
</code></pre><p><code>setTimeout()</code> 将第二行代码推迟到 <code>1000ms</code> 之后执行。</p><p>写 <code>JavaScript</code> 代码的时候，我们会经常将 <code>setTimeout()</code> 的第二个参数设为 <code>0</code>，就表示当前代码执行完（执行栈清空）以后，立即执行（ <code>0ms</code> 间隔）指定的回调函数。</p><p><strong>注意</strong>：<code>setTimeout()</code> 只是将事件插入了 <strong>任务队列</strong>，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。如果当前代码耗时很长，有可能要等很久，所以并没有办法保证回调函数一定会在 <code>setTimeout()</code> 指定的时间执行。</p></div><hr><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.88rem}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{color:#fff}.reward-tabs .wechat-tab .active{color:#fff;background-color:#22ab38}.reward-tabs .alipay-tab .active{color:#fff;background-color:#019fe8}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"> <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close"><i class="fa fa-close"></i></a><h4 class="reward-title">请我喝杯咖啡?</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs"><li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li><li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li></ul><div id="wechat"> <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div><div id="alipay"> <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码"></div></div></div></div></div></div><script>$(function(){$("#reward .reward-link").on("click",function(){$("#rewardModal").openModal()}),$("#rewardModal .close").on("click",function(){$("#rewardModal").closeModal()})})</script><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div></div><script src="/libs/share/js/social-share.min.js"></script><div class="reprint"><p> <span class="reprint-tip">转载请注明:</span> <a href="https://togoblog.cn" class="b-link-green">Deepspace</a><i class="fa fa-angle-right fa-lg fa-fw text-color"></i> <a href="/event-loop-in-browser/" class="b-link-green">浏览器中的事件循环机制</a></p></div></div></div><div class="article" data-aos="fade-up"><div class="card relate-article-wrapper"><header class="relate-article-header">相关文章&nbsp;<i class="fa fa-arrow-right"></i></header><div class="relate-post-box"><div class="relate-post"> <span>1、</span><a id="relate-post-link" href="/eventemitter/">EventEmitter</a></div><div class="relate-post"> <span>2、</span><a id="relate-post-link" href="/express-mongoose/">Express + Mongoose 实现增删改查</a></div><div class="relate-post"> <span>3、</span><a id="relate-post-link" href="/event-loop-in-nodejs/">Node.JS 中的事件循环机制</a></div></div></div></div><div class="disqus-card card" data-aos="fade-up"><div id="disqus_thread" class="card-content"><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><script type="text/javascript">
    disqus_config = function () {
        this.page.url = 'https://togoblog.cn/event-loop-in-browser/';
        this.page.identifier = '/event-loop-in-browser/';
        this.page.title = '浏览器中的事件循环机制';
    };
    let disqus_shortname = 'https-togoblog-cn';

    (function () { // DON'T EDIT BELOW THIS LINE
        let d = document, s = d.createElement('script');
        // 如：s.src = 'https://Deepspace.disqus.com/embed.js';
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script></div></div><div class="col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title">目录</div><div id="toc-content"></div></div></div></div><script src="/libs/tocbot/tocbot.min.js"></script><script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingSelector: 'h2, h3, h4, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script></main><footer class="page-footer bg-color"><div class="container row center-align"><div class="col s12 m8 l8 copy-right"> <span>COPYRIGHT 2020 DEEPSPACE. ALL RIGHTS RESERVED.</span></div><div class="col s12 m4 l4 social-link"><a href="https://github.com/IDeepspace" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fa fa-github"></i></a><a href="mailto:cxin1427@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fa fa-envelope-open"></i></a><a href="#!" class="tooltipped" data-tooltip="QQ: 690862036" data-position="top" data-delay="50"><i class="fa fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fa fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"> <span class="title">搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input" autofocus></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script type="text/javascript">searchFunc("/search.xml","searchInput","searchResult")</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fa fa-angle-up"></i></a></div><script src="/libs/materialize/js/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script></body></html>