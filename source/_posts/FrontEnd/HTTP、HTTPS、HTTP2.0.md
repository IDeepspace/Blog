---
title: HTTP、HTTPS、HTTP2.0
author: Deepspace
categories: FrontEnd
date: 2019-05-01
urlname: http-https-http2
tags:
  - HTTP
---



## HTTP、HTTPS、HTTP2.0

本篇博客将介绍 `HTTP` 的相关概念。



### 一、基本概念

#### 1、HTTP

`HTTP`（`HyperText Transfer Protocol`：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 **简单来说就是一种发布和接收 `HTML` 页面的方法，被用于在「`Web` 浏览器」和「网站服务器」之间传递信息**。

`HTTP` 默认工作在 `TCP` （`Transmission Control Protocol`，面向连接的协议） `80` 端口，用户访问网站 `http://` 打头的都是标准 `HTTP` 服务。 



#### 2、HTTP 报文

**请求报文**

`HTTP` 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：

```
<method> <request-URL> <version>
<headers>

<entity-body>
```

`HTTP` 定义了与服务器交互的不同方法，最基本的方法有 4 种，分别是 `GET`，`POST`，`PUT`，`DELETE`。`URL`全称是资源描述符，我们可以这样认为：一个 `URL` 地址，它用于描述一个网络上的资源，而 `HTTP` 中的 `GET`，`POST`，`PUT`，`DELETE` 就对应着对这个资源的查，增，改，删 4 个操作。



**响应报文**

`HTTP` 响应与 `HTTP` 请求相似，`HTTP` 响应也由 3 个部分构成，分别是：

- 状态行
- 响应头(`Response Header`)
- 响应正文

状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。



#### 3、HTTP 的状态码

下面是 HTTP 响应报文中的状态码：

`2XX` 成功

- `200 OK`，表示从客户端发来的请求在服务器端被正确处理 👏
- `201 Created` 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立 👏
- `202 Accepted` 请求已接受，但是还没执行，不保证完成请求
- `204 No content`，表示请求成功，但响应报文不含实体的主体部分 👏
- `206 Partial Content`，进行范围请求 

`3XX` 重定向

- `301 moved permanently`，永久性重定向，表示资源已被分配了新的 `URL`
- `302 found`，临时性重定向，表示资源临时被分配了新的 `URL` 👏
- `303 see other`，表示资源存在着另一个 `URL`，应使用 `GET` 方法丁香获取资源
- `304 not modified`，表示服务器允许访问资源，但因发生请求未满足条件的情况
- `307 temporary redirect`，临时重定向，和 `302` 含义相同

`4XX` 客户端错误

- `400 bad request`，请求报文存在语法错误 👏
- `401 unauthorized`，表示发送的请求需要有通过 `HTTP` 认证的认证信息 👏
- `403 forbidden`，表示对请求资源的访问被服务器拒绝 👏
- `404 not found`，表示在服务器上没有找到请求的资源 👏
- `408 Request timeout`，客户端请求超时
- `409 Confict`， 请求的资源可能引起冲突

`5XX` 服务器错误

- `500 internal sever error`，表示服务器端在执行请求时发生了错误 👏
- `501 Not Implemented` 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
- `503 service unavailable`，表明服务器暂时处于超负载或正在停机维护，无法处理请求
- `505 http version not supported` 服务器不支持，或者拒绝支持在请求中使用的 `HTTP` 版本



#### 4、持久连接

我们知道 `HTTP` 协议采用「请求-应答」模式，当使用普通模式，即非 `Keep-Alive` 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接，所以说 `HTTP` 协议为无连接的协议。当使用 `Keep-Alive` 模式（又称持久连接、连接重用）时，`Keep-Alive` 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，`Keep-Alive` 功能避免了建立或者重新建立连接。

在 `HTTP1.0` 版本中，并没有官方的标准来规定 `Keep-Alive` 如何工作，每条请求报文只能写一个 `URI`，也就是一次只能写一个资源路径，这就造成一次只能获取一个文件，对于服务器来说可以对请求进行逐个处理，每处理完一个就关闭连接，这样的非持久连接可以节省资源，不过随着互联网的发展，一次一个请求的方式很难满足实际需求，而且每次都会进行一个 `TCP` 连接。

因此**在 `HTTP1.1` ，默认连接为持久连接，服务器返回消息，客户端可以继续发起下一个请求，如果没有要发送的了，客户端最后发送 `Connection: close` 首部给服务器，这样就会进行关闭**。



#### 5、无状态

前面说到，`HTTP1.0` 中，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接，所以说 `HTTP` 协议为无连接的协议，也称作**无状态**。其实这样可以大大减少服务器的资源消耗。但是很多网站是提供用户登录功能的，如果是无状态的话，用户登录一次，第二次访问又需要输入信息重新登录，这显然是很麻烦的，为了保持状态，就有了 `Cookie` 这项技术。

这项技术需要在首部字段加上 `Cookie` 信息，这样就能够实现保持登录状态了。



#### 6、为什么有了 HTTP 为什么还要 HTTPS ？

`HTTP` 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 `Web` 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，`HTTP` 协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 

`HTTPS`（`Hypertext Transfer Protocol Secure`：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。`HTTPS` 经由 `HTTP` 进行通信，但利用 `SSL/TLS` 来加密数据包。`HTTPS` 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 

`HTTPS` 默认工作在 `TCP` 协议 `443` 端口，它的工作流程一般如以下方式：

- `TCP` 三次同步握手

- 客户端验证服务器数字证书

- `DH` 算法协商对称加密算法的密钥、`hash` 算法的密钥

- `SSL` 安全加密隧道协商完成

- 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 `hash` 算法进行数据完整性保护，保证数据不被篡改。



#### 7、HTTP 与 HTTPS 区别

- `HTTP` 明文传输，数据都是未加密的，安全性较差，`HTTPS`（`SSL+HTTP`）数据传输过程是加密的，安全性较好。

- 使用 `HTTPS` 协议需要到 `CA`（`Certificate Authority`，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。

- `HTTP` 页面响应速度比 `HTTPS` 快，主要是因为 `HTTP` 使用 `TCP` 三次握手建立连接，客户端和服务器需要交换 `3` 个包；而 `HTTPS `除了 `TCP` 的三个包，还要加上 `ssl` 握手需要的 `9` 个包，所以一共是 `12` 个包。

- `HTTP` 和 `HTTPS` 使用的是完全不同的连接方式，用的端口也不一样，前者是 `80`，后者是 `443`。

- `HTTPS` 其实就是建构在 `SSL/TLS` 之上的 `HTTP` 协议，所以，`HTTPS` 比 `HTTP` 要更耗费服务器资源。



#### 8、HTTP2 相对于 HTTP1.x 有什么优势和特点？

`HTTP/2`（超文本传输协议第 2 版，最初命名为 `HTTP2.0`），是 `HTTP` 协议的第二个主要版本。`HTTP/2` 是HTTP协议自1999年 `HTTP1.1` 发布后的首个更新，主要基于 `SPDY` 协议。 

`HTTP2.0` 的特点是：在不改动 `HTTP` 语义、方法、状态码、`URI` 及首部字段的情况下，大幅度提高了 `web` 性能。



**什么是 SPDY 协议？**

`SPDY` 是 `Speedy` 的昵音，意为“更快”。它是 `Google` 开发的基于 `TCP` 协议的应用层协议。目标是优化 `HTTP` 协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。`SPDY` 协议的核心思想是尽量减少 `TCP` 连接数。`SPDY` 并不是一种用于替代 `HTTP` 的协议，而是对 `HTTP` 协议的增强。



**HTTP1.x 的缺点**

1. `HTTP/1.0` 一次只允许在一个 `TCP` 连接上发起一个请求，`HTTP/1.1` 使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
2. 单向请求，只能由客户端发起。
3. 请求报文与响应报文首部信息冗余量大。
4. 数据未压缩，导致数据的传输量大。



**HTTP2.0 特点**

1. 二进制传输
2. **多路复用（就是在同一个 `TCP` 连接，同一时刻可以传输多个 `HTTP` 请求）**
3. `Header` 压缩
4. 服务器 `push`
5. 更安全



### 二、TCP 三次握手和四次挥手

`TCP` 协议**通过三次握手的形式建立一个可靠的连接**，建立成功之后开始发送数据。发送数据完了之后，会**以四次挥手的形式来终止连接**。

#### 1、三次握手

<img src="https://github.com/IDeepspace/ImageHosting/raw/master/FrontEnd/tcp-three-way-handshake.jpg" alt="tcp-three-way-handshake.jpg" style="zoom:87%;" />

<p align='center'>（图片来自网络）</p>

- 第一次握手：客户端尝试连接服务器，向服务器发送 `syn` 包（同步序列编号 `Synchronize Sequence Numbers`），`syn=j`；发送完成之后，客户端进入 `SYN_SEND` 状态等待服务器确认；

- 第二次握手：服务器接收客户端 `syn` 包并确认（`ack=j+1`，`ack` 是 `acknowledgment` 的缩写，意为答复），同时向客户端也发送一个  `SYN` 包（`syn=k`，用来给客户端回应使用），所以会发送两个内容 —— `SYN+ACK` 包，`ACK` 的值是根据客户端发送的 `syn=j` 来确认的，这样客户端收到回应的时候就能准确知道是服务端的回应了；发送完成之后，服务器进入 `SYN_RCVD` 状态；

- 第三次握手：客户端收到服务器的 `SYN+ACK` 包，向服务器发送确认包 `ACK`（`ack=k+1`），此包发送完毕，客户端和服务器进入 `ESTABLISHED` 状态，表示连接成功，完成三次握手，这个时候就可以传输数据了。



#### 2、四次挥手

`TCP` 的连接的断开需要发送四个包，因此称为四次挥手(`Four-way handshake`)，也叫做改进的三次握手。

客户端或服务器均可主动发起挥手动作，在 `socket` 编程中，任何一方执行 `close()` 操作即可产生挥手操作。

<img src="https://github.com/IDeepspace/ImageHosting/raw/master/FrontEnd/tcp-connection-closed-four-way-handshake.png" alt="tcp-connection-closed-four-way-handshake" style="zoom:77%;" />

<p align='center'>（图片来自网络）</p>

- 第一次挥手（`FIN=1，seq=x`）：假设客户端想要关闭连接，客户端发送一个 `FIN` （`Finish` 的缩写，表示结束）标志位置为 `1` 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

- 第二次挥手（`ACK=1，ACKnum=x+1`）：服务器端确认客户端的 `FIN` 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

- 第三次挥手（`FIN=1，seq=y`）：服务器端准备好关闭连接时，向客户端发送结束连接请求，`FIN` 置为1。发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个 `ACK`。

- 第四次挥手（`ACK=1，ACKnum=y+1`）：客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 `ACK` 包。服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

  客户端等待了某个固定时间（两个最大段生命周期，`2MSL`，`2 Maximum Segment Lifetime`）之后，没有收到服务器端的 `ACK` ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。



这里有一张简单图示，可以帮助理解三次握手和四次挥手：

<img src="https://github.com/IDeepspace/ImageHosting/raw/master/FrontEnd/three-four-handshake.png" alt="three-four-handshake.png" style="zoom: 50%;" />

<p align='center'>（图片来自网络）</p>



#### 3、为什么握手需要三次，而挥手却需要四次？

握手的时候，`A` 和 `B` 打个招呼，`B `可以直接把自己的 `SYN` 信息和对 `A` 的回应 `ACK` 信息一起带上，但是挥手的时候，`A` 说我要断开了，`B` 还没发完最后的数据，因此需要先回应一下 `A`，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了 `2` 步：

（1）回应 `A`； 

（2）发送自己的最后一个数据。



#### 4、为什么 A 进入 TIME_WAIT 需要等待最大报文段生存的时间后，才能关闭？

（1）第一，**为了保证 `A` 发送的最后一个 `ACK` 报文能够到达 `B`**。这个 `ACK` 报文段有可能丢失，因而使处在 `LAST-ACK` 状态的 `B` 收不到对已发送的 `FIN+ACK` 报文段的确认。`B` 会超时重传这个 `FIN+ACK` 报文段，而 `A` 就能在 `2MSL` 时间内收到这个重传的 `FIN+ACK` 报文段。如果 `A` 在 `TIME-WAIT` 状态不等待一段时间，而是在发送完 `ACK` 报文段后就立即释放连接，就无法收到 `B` 重传的 `FIN+ACK` 报文段，因而也不会再发送一次确认报文段。这样，`B` 就无法按照正常的步骤进入 `CLOSED` 状态。

（2）`A` 在发送完 `ACK` 报文段后，再经过 `2MSL` 时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。



### 三、UDP 是什么？

`TCP/IP` 协议是一个协议簇。里面包括很多协议的，**`UDP` 只是其中的一个**， 之所以命名为 `TCP/IP` 协议，因为 `TCP`、`IP` 协议是两个很重要的协议，就用它们俩命名了。

`UDP` 传输协议是 「 无连接 」 的， 「无连接」 就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。它是一种不可靠的、面向无连接、可以实现多对一、一对多和一对一连接的通信协议。

1. `UDP` 在传输数据前 「 不需要建立通道 」 ，在数据传输完毕后也不需要将通道关闭。
2. 只要客户端给服务端发送一个请求，服务端就会 「 一次性 」 地把所有数据发送完毕。`UDP` 在传输数据时 「 不会对数据的完整性进行验证 」 ，在数据丢失或数据出错时也 「 不会要求重新传输 」 ，因此也节省了很多用于验证数据包的时间，所以以 `UDP` 建立的连接的延迟会比以 `TCP` 建立的连接的延迟更低。
3. `UDP` 不会根据当前的网络情况来控制数据的发送速度，因此无论网络情况是好是坏，服务端都会以 「 恒定的速率 」 发送数据。虽然这样有时会造成数据的丢失与损坏，但是这一点对于一些实时应用来说是十分重要的。

基于以上三点，`UDP` 在数据传输方面「 速度更快 」，「 延迟更低 」，「 实时性更好 」， 因此被广泛地用于通信领域和视频网站当中。



#### 1、TCP/UDP 的区别

- `TCP` 是面向连接的，`UDP` 是无连接的。

- `TCP` 保证了数据的可靠传输，`UDP` 是有可能丢包的。
- `TCP` 的结构比较复杂，`UDP` 简单。
- `TCP` 慢，`UDP` 快。

