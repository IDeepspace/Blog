**引言**


在你平时的前端开发工作中，有没有遇到过这样的问题？

你的产品代码是用一个老旧的前端框架搭建的，你想把新的框架应用到项目中，却发现新技术栈的某些编译配置在当前代码库中无法使用；
有一天你想在你的产品代码库中构建一个响应式Web应用程序，但是却找不到一个合适的入口去进行代码集成；
代码越来越臃肿，前进的脚步被往日堆积的技术债所阻碍，你时不时脑中都会涌起重写的冲动，却不敢轻举妄动；

想要解决这些痛点，也许你可以尝试一下 “微前端”。



**什么是微前端**

微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。它的特点有：

\- 增量升级：多个小型微前端组装成的应用，其每个部分都是独立的，可按需进行增量升级，而不影响产品的架构、交互等。

- 简单的解耦代码库：将一个大的单体应用拆解为多个小型微前端项目，以达到解耦效果。
- 独立部署：每一个微前端负责自己的部署流程、独立完成上线流程。
- 自治团队：团队可独立定义自己的命名规则、代码规范、技术栈、开发流程等。

**微前端实践方案**

下面简单来举一个例子。比如说，一个Book Store系统分别由以下几部分组成：

搜索书籍模块（以下称为模块A）：可以根据用户输入的搜索条件搜索出满足条件的书籍并展示。
书籍信息模块（以下称为模块B）：展示书籍信息、购买图书。
用户信息模块（以下称为模块C）：查看订单记录、物流信息、管理支付密码等。

将这个大的单体网上书店应用拆解为三个小的微前端项目， 每个微前端项目都将由一个独立的团队来负责，而且每一个团队都可以独立的开发、测试、部署、维护自身模块而不用担心和其他模块冲突。



下面以此为例来介绍几种微前端的实践方案：



**1. 基于路由分发的集成**



路由分发式微前端，即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过 HTTP 服务器的反向代理或者是应用框架自带的路由来解决。



在下面这个示例中，不同的页面的请求被分发到不同的服务器上。



```
http {
  server {
    listen       80;
    server_name  www.micro-frontend-demo.com;
    location /browse {
      proxy_pass http://192.168.1.5:8000/browse;
    }
    location /order {
      proxy_pass http://192.168.1.6/order;
    }
    location /profile {
      proxy_pass http://192.168.1.7/profile;
    }
    location / {
      proxy_pass /;
    }
  }
}
```



**2. 构建时集成**



构建时集成微前端，指的是把不同的微前端打成不同的 package，然后将其作为主工程的依赖。如下为一个 **package.json** 的示例。



```
{
  "name": "@feed-me/container",
  "version": "1.0.0",
  "description": "A food delivery web app",
  "dependencies": {
    "@feed-me/browse-restaurants": "^1.2.3",
    "@feed-me/order-food": "^4.5.6",
    "@feed-me/user-profile": "^7.8.9"
  }
}
```



值得一提的是，这种做法非常不值得推荐，因为每次只要有一个依赖更新了，我们将需要重新编译和发布每一个微前端，然后再将其集成到主工程中。这种做法再次引入了复杂的发布流程，我们想要解构复杂发布流程的目标就无法达成了。因此，我们应该着眼于在运行时去集成每一个小的微前端。



**3. 运行时用 iframe 创建容器**



iframe 这个古老的技术，有时候却还是很有用。



iframe 可以创建一个全新的独立的宿主环境，这意味着我们的前端应用之间可以相互独立运行。



```
<html>
  <head>
    <title>Book Store</title>
  </head>
  <body>
    <h1>Welcome to Book Store!</h1>

    <iframe id="micro-frontend-container"></iframe>

    <script type="text/javascript">
      const microFrontendsByRoute = {
        '/browse': 'https://browse.micro-frontend-demo.com/index.html',
        '/order': 'https://order.micro-frontend-demo.com/index.html',
        '/profile': 'https://profile.micro-frontend-demo.com/index.html',
      };

      const iframe = document.getElementById('micro-frontend-container');
      iframe.src = microFrontendsByRoute[window.location.pathname];
    </script>
  </body>
</html>
```



**4.  通过JavaScript进行运行时集成**



把每个微前端打包好的 bundle.js 文件都通过 <script> 脚本引入到页面中，然后在用户操作时，加载对应的应用，并可以卸载对应的服务。



```
<html>
  <head>
    <title>Book Store!</title>
  </head>
  <body>
    <h1>Welcome to Book Store!</h1>

    <!-- These scripts don't render anything immediately -->
    <!-- Instead they attach entry-point functions to `window` -->
    <script src="https://browse.micro-frontend-demo.com/bundle.js"></script>
    <script src="https://order.micro-frontend-demo.com/bundle.js"></script>
    <script src="https://profile.micro-frontend-demo.com/bundle.js"></script>

    <div id="micro-frontend-root"></div>

    <script type="text/javascript">
      // These global functions are attached to window by the above scripts
      const microFrontendsByRoute = {
        '/': window.renderBrowseBooks,
        '/order': window.renderOrderBook,
        '/profile': window.renderProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];

      // Having determined the entry-point function, we now call it,
      // giving it the ID of the element where it should render itself
      renderFunction('micro-frontend-root');
    </script>
  </body>
</html>
```



以上例子为简单的说明示意，具体详细解析可参见 https://martinfowler.com/articles/micro-frontends.html#TheExampleInDetail



**5. 通过Web组件进行运行时集成**



与上文 ***通过JavaScript进行运行时集成*** 中的变体是用于微前端容器实例化的HTML元素。而本例中，则是用 Web Component 来作为微前端的容器。



值得注意的是，



> Web Components 是一套不同的技术，允许你创建可重用的定制元素（它们的功能封装在你的代码之外）并且在你的 Web 应用中使用它们。



 而 Web Component 于微前端中的应用，现在也正处于摸索阶段。



```
<html>
  <head>
    <title>Book Store!</title>
  </head>
  <body>
    <h1>Welcome to Book Store!</h1>

    <!-- These scripts don't render anything immediately -->
    <!-- Instead they each define a custom element type -->
    <script src="https://browse.micro-frontend-demo.com/bundle.js"></script>
    <script src="https://order.micro-frontend-demo.com/bundle.js"></script>
    <script src="https://profile.micro-frontend-demo.com/bundle.js"></script>

    <div id="micro-frontend-root"></div>

    <script type="text/javascript">
      // These element types are defined by the above scripts
      const webComponentsByRoute = {
        '/': 'micro-frontend-browse-books',
        '/order': 'micro-frontend-order-book',
        '/profile': 'micro-frontend-profile',
      };
      const webComponentType = webComponentsByRoute[window.location.pathname];

      // Having determined the right web component custom element type,
      // we now create an instance of it and attach it to the document
      const root = document.getElementById('micro-frontend-root');
      const webComponent = document.createElement(webComponentType);
      root.appendChild(webComponent);
    </script>
  </body>
</html>
```

**总结**

此时，本文开篇中提到的那些问题，你心中现在有答案了吗？

每一门新技术都是为了解决问题而诞生，希望大家通过本篇博客可以对微前端有所了解。